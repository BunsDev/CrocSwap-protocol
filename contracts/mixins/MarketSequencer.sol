// SPDX-License-Identifier: Unlicensed

pragma solidity >=0.8.4;

import '../libraries/Directives.sol';
import '../libraries/PoolSpecs.sol';
import '../libraries/PriceGrid.sol';
import '../libraries/SwapCurve.sol';
import '../libraries/CurveMath.sol';
import '../libraries/CurveRoll.sol';
import '../libraries/CurveCache.sol';
import '../libraries/Chaining.sol';
import './PositionRegistrar.sol';
import './LiquidityCurve.sol';
import './LevelBook.sol';
import './ColdInjector.sol';
import './TradeMatcher.sol';

import '../interfaces/ICrocSwapHistRecv.sol';

import "hardhat/console.sol";

/* @title Market sequencer.
 * @notice Mixin class that's responsibile for coordinating one or multiple sequetial
 *         trade actions within a single liqudity pool. */
contract MarketSequencer is TradeMatcher {

    using SafeCast for int256;
    using SafeCast for int128;
    using SafeCast for uint256;
    using SafeCast for uint128;
    using TickMath for uint128;
    using PoolSpecs for PoolSpecs.Pool;
    using SwapCurve for CurveMath.CurveState;
    using CurveRoll for CurveMath.CurveState;
    using CurveMath for CurveMath.CurveState;
    using CurveCache for CurveCache.Cache;
    using Directives for Directives.ConcentratedDirective;
    using PriceGrid for PriceGrid.ImproveSettings;
    using Chaining for Chaining.PairFlow;
    using Chaining for Chaining.RollTarget;

    /* @notice Performs a sequence of an arbitrary potential combination of mints, 
     *         burns, and swaps on a single pool. 
     *
     * @param flow Output accumulator, into which we'll net and and add the token flows 
     *             associated with the trade actions in this call.
     * @param dir A directive specifying an arbitrary sequences of action.
     * @param cntx Provides the execution context for the operation, including the pool
     *             to execute on and it's pre-loaded specs, off-grid price improvement
     *             settings, and parameters for rolling gap-failled quantities if they
     *             appear in the directive. */
    function tradeOverPool (Chaining.PairFlow memory flow,
                            Directives.PoolDirective memory dir,
                            Chaining.ExecCntx memory cntx) internal {
        // To avoid repeatedly loading and storing the curve on each operation, we load
        // it once into memory...
        CurveCache.Cache memory curve;
        curve.curve_ = snapCurve(cntx.pool_.hash_);
        applyToCurve(flow, dir, curve, cntx);
        /// ...Then check it back into storage when complete
        commitCurve(cntx.pool_.hash_, curve.curve_);
    }

    /* @notice Performs a single swap over the pool.
     * @param dir The user-specified directive governing the size, direction and limit
     *            price of the swap to be performed.
     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.
     * @return flow The net token flows generated by the swap. */
    function swapOverPool (Directives.SwapDirective memory dir,
                           PoolSpecs.PoolCursor memory pool)
        internal returns (Chaining.PairFlow memory flow) {
        CurveMath.CurveState memory curve = snapCurve(pool.hash_);
        sweepSwapLiq(flow, curve, curve.priceRoot_.getTickAtSqrtRatio(), dir, pool);
        commitCurve(pool.hash_, curve);
    }

    /* @notice Mints concentrated liquidity in the form of a range order on to the pool.
     *
     * @param bidTick The price tick associated with the lower boundary of the range
     *                order.
     * @param askTick The price tick associated with the upper boundary of the range
     *                order.
     * @param liq The amount of liquidity being minted represented as the equivalent to
     *            sqrt(X*Y) in a constant product AMM pool.
     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.
     * @param minPrice The minimum acceptable curve price to mint liquidity. If curve
     *                 price falls outside this point, the transaction is reverted.
     * @param maxPrice The maximum acceptable curve price to mint liquidity. If curve
     *                 price falls outside this point, the transaction is reverted.
     *
     * @return baseFlow The total amount of base-side token collateral that must be
     *                  committed to the pool as part of the mint. Will always be
     *                  positive as it's paid to the pool from the user.
     * @return quoteFlow The total amount of quote-side token collateral that must be
     *                   committed to the pool as part of the mint. */
    function mintOverPool (int24 bidTick, int24 askTick, uint128 liq,
                           PoolSpecs.PoolCursor memory pool,
                           uint128 minPrice, uint128 maxPrice)
        internal returns (int128 baseFlow, int128 quoteFlow) {
        CurveMath.CurveState memory curve = snapCurveInRange
            (pool.hash_, minPrice, maxPrice);
        (baseFlow, quoteFlow) =
            mintRange(curve, curve.priceRoot_.getTickAtSqrtRatio(),
                      bidTick, askTick, liq, pool.hash_);
        PriceGrid.verifyFit(bidTick, askTick, pool.head_.tickSize_);
        commitCurve(pool.hash_, curve);
    }

    /* @notice Burns concentrated liquidity in the form of a range order on to the pool.
     *
     * @param bidTick The price tick associated with the lower boundary of the range
     *                order.
     * @param askTick The price tick associated with the upper boundary of the range
     *                order.
     * @param liq The amount of liquidity to burn represented as the equivalent to
     *            sqrt(X*Y) in a constant product AMM pool.
     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.
     * @param minPrice The minimum acceptable curve price to mint liquidity. If curve
     *                 price falls outside this point, the transaction is reverted.
     * @param maxPrice The maximum acceptable curve price to mint liquidity. If curve
     *                 price falls outside this point, the transaction is reverted.
     *
     * @return baseFlow The total amount of base-side token collateral that is returned
     *                  from the pool as part of the burn. Will always be
     *                  negative as it's paid from the pool to the user.
     * @return quoteFlow The total amount of quote-side token collateral that is returned
     *                   from the pool as part of the burn. */
    function burnOverPool (int24 bidTick, int24 askTick, uint128 liq,
                           PoolSpecs.PoolCursor memory pool,
                           uint128 minPrice, uint128 maxPrice)
        internal returns (int128 baseFlow, int128 quoteFlow) {
        CurveMath.CurveState memory curve = snapCurveInRange
            (pool.hash_, minPrice, maxPrice);
        (baseFlow, quoteFlow) =
            burnRange(curve, curve.priceRoot_.getTickAtSqrtRatio(),
                      bidTick, askTick, liq, pool.hash_);
        commitCurve(pool.hash_, curve);
    }

    /* @notice Mints ambient liquidity on to the pool's curve.
     *
     * @param liq The amount of liquidity being minted represented as the equivalent to
     *            sqrt(X*Y) in a constant product AMM pool.
     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.
     * @param minPrice The minimum acceptable curve price to mint liquidity. If curve
     *                 price falls outside this point, the transaction is reverted.
     * @param maxPrice The maximum acceptable curve price to mint liquidity. If curve
     *                 price falls outside this point, the transaction is reverted.
     *
     * @return baseFlow The total amount of base-side token collateral that must be
     *                  committed to the pool as part of the mint. Will always be
     *                  positive as it's paid to the pool from the user.
     * @return quoteFlow The total amount of quote-side token collateral that must be
     *                   committed to the pool as part of the mint. */
    function mintOverPool (uint128 liq, PoolSpecs.PoolCursor memory pool,
                           uint128 minPrice, uint128 maxPrice)
        internal returns (int128 baseFlow, int128 quoteFlow) {
        CurveMath.CurveState memory curve = snapCurveInRange
            (pool.hash_, minPrice, maxPrice);
        (baseFlow, quoteFlow) =
            mintAmbient(curve, liq, pool.hash_);
        commitCurve(pool.hash_, curve);
    }

    
    /* @notice Burns ambient liquidity on to the pool's curve.
     *
     * @param liq The amount of liquidity to burn represented as the equivalent to
     *            sqrt(X*Y) in a constant product AMM pool.
     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.
     * @param minPrice The minimum acceptable curve price to mint liquidity. If curve
     *                 price falls outside this point, the transaction is reverted.
     * @param maxPrice The maximum acceptable curve price to mint liquidity. If curve
     *                 price falls outside this point, the transaction is reverted.
     *
     * @return baseFlow The total amount of base-side token collateral that is returned
     *                  from the pool as part of the burn. Will always be negative
     *                  as it's paid from the pool to the user.
     * @return quoteFlow The total amount of quote-side token collateral that is returned
     *                   from the pool as part of the burn. */
    function burnOverPool (uint128 liq, PoolSpecs.PoolCursor memory pool,
                           uint128 minPrice, uint128 maxPrice)
        internal returns (int128 baseFlow, int128 quoteFlow) {
        CurveMath.CurveState memory curve = snapCurveInRange
            (pool.hash_, minPrice, maxPrice);
        (baseFlow, quoteFlow) =
            burnAmbient(curve, liq, pool.hash_);
        commitCurve(pool.hash_, curve);
    }

    /* @notice Initializes a new liquidity curve for the pool.
       
     * @dev This does *not* check whether the curve was previously initialized. It's
     *      the caller's responsibility to make sure this is never called on an already
     *      initialized pool.
     *
     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.
     * @param price The initial price to set the curve at. Represented as the square root
     *              of price in Q64.64 fixed point.
     * @param initLiq The initial ambient liquidity commitment that will be permanetely 
     *                locked in the pool. Represeted as sqrt(X*Y) constant-product AMM
     *                liquidity.
     *
     * @return baseFlow The total amount of base-side token collateral that must be
     *                  committed to the pool as part of the mint. Will always be
     *                  positive as it's paid to the pool from the user.
     * @return quoteFlow The total amount of quote-side token collateral that must be
     *                   committed to the pool as part of the mint. */     
    function initCurve (PoolSpecs.PoolCursor memory pool,
                        uint128 price, uint128 initLiq)
        internal returns (int128 baseFlow, int128 quoteFlow) {
        CurveMath.CurveState memory curve = snapCurveInit(pool.hash_);
        initPrice(curve, price);
        if (initLiq > 0) {
            (baseFlow, quoteFlow) = lockAmbient(curve, initLiq);
        }
        commitCurve(pool.hash_, curve);
    }

    /* @notice Appplies the pool directive on to a pre-loaded liquidity curve. */
    function applyToCurve (Chaining.PairFlow memory flow,
                           Directives.PoolDirective memory dir,
                           CurveCache.Cache memory curve,
                           Chaining.ExecCntx memory cntx) private {
        if (!dir.chain_.swapDefer_) {
            applySwap(flow, dir.swap_, curve, cntx);
        }
        applyAmbient(flow, dir.ambient_, curve, cntx);
        applyConcentrateds(flow, dir.conc_, curve, cntx);
        if (dir.chain_.swapDefer_) {
            applySwap(flow, dir.swap_, curve, cntx);
        }
    }

    /* @notice Applies the swap directive on to a pre-loaded liquidity curve. */
    function applySwap (Chaining.PairFlow memory flow,
                        Directives.SwapDirective memory dir,
                        CurveCache.Cache memory curve,
                        Chaining.ExecCntx memory cntx) private {
        if (isRoll(dir)) {
            cntx.roll_.plugSwapGap(dir, flow);
        }
        if (dir.qty_ != 0) {
            callSwap(flow, curve, dir, cntx.pool_);            
        }
    }

    /* @notice Returns true if the swap directive indicates that it wants to use a 
     *         rolling gap-filled plugged into quantity instead of a pre-specified 
     *         quantity. */
    function isRoll (Directives.SwapDirective memory dir) private pure returns (bool) {
        return dir.limitPrice_ > 0 && dir.qty_ == 0;
    }

    /* @notice Applies an ambient liquidity directive to a pre-loaded liquidity curve. */
    function applyAmbient (Chaining.PairFlow memory flow,
                           Directives.AmbientDirective memory dir,
                           CurveCache.Cache memory curve,
                           Chaining.ExecCntx memory cntx) private {
        (uint128 liq, bool isAdd) = (dir.liquidity_, dir.isAdd_);

        if (isRoll(liq, isAdd)) {
            (liq, isAdd) = cntx.roll_.plugLiquidity(curve.curve_, flow);
        }
        
        if (liq > 0) {
            (int128 base, int128 quote) = isAdd ?
                callMintAmbient(curve, liq, cntx.pool_.hash_) :
                callBurnAmbient(curve, liq, cntx.pool_.hash_);
        
            flow.accumFlow(base, quote);
        }
    }

    /* @notice Applies zero, one or a series of concentrated liquidity directives to a 
     *         pre-loaded liquidity curve. */
    function applyConcentrateds (Chaining.PairFlow memory flow,
                                 Directives.ConcentratedDirective[] memory dirs,
                                 CurveCache.Cache memory curve,
                                 Chaining.ExecCntx memory cntx) private {
        for (uint i = 0; i < dirs.length; ++i) {
            for (uint j = 0; j < dirs[i].bookends_.length; ++j) {
                (int24 lowTick, int24 highTick, bool isAdd, uint128 liquidity) =
                    dirs[i].sliceBookend(j);

                (int128 nextBase, int128 nextQuote) = applyConcentrated
                    (curve, flow, cntx, lowTick, highTick, isAdd, liquidity);
                flow.accumFlow(nextBase, nextQuote);
            }
        }
    }

    /* Applies a single concentrated liquidity range order to the liquidity curve. */
    function applyConcentrated (CurveCache.Cache memory curve,
                                Chaining.PairFlow memory flow,
                                Chaining.ExecCntx memory cntx,
                                int24 lowTick, int24 highTick, bool isAdd, uint128 liq)
        private returns (int128, int128) {
        if (isRoll(liq, isAdd)) {
            (liq, isAdd) = Chaining.plugLiquidity(cntx.roll_, curve.curve_,
                                                  flow, lowTick, highTick);
        }

        if (isAdd) {
            bool offGrid = cntx.improve_.verifyFit(lowTick, highTick, liq,
                                                   cntx.pool_.head_.tickSize_,
                                                   curve.pullPriceTick());
            if (offGrid) {
                // Off-grid positions are set with atomic liquidity. That prevents
                // partial burns on these positions. Since off-grid size eligibility
                // is only checked at mint time this is necessary to prevent under-sized
                // off-grid orders.
                markPosAtomic(agentMintKey(), cntx.pool_.hash_, lowTick, highTick);
            }
        }

        if (liq == 0) { return (0, 0); }
        return isAdd ?
            callMintRange(curve, lowTick, highTick, liq, cntx.pool_.hash_) :
            callBurnRange(curve, lowTick, highTick, liq, cntx.pool_.hash_);
    }

    /* @notice Returns true if the liquidity directive fields indicates that it wants to 
     *         use a rolling gap-filled plugged into quantity instead of a pre-specified 
     *         quantity. */
    function isRoll (uint128 liq, bool isAdd) private pure returns (bool) {
        return liq == 0 && isAdd == true;
    }

}
